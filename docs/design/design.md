# Design Changes Analysis

I wanted to break the card rules into behaviors, so that I could add new cards with specific logic without changing existing code, which follows the Open/Closed Principle. In the original design, `GameUI` contains all the card execution logic with a long switch statement and helper methods like `playShuffle()` and `playExplodingKitten()`. The 1700+ line `GameUI` class handles both interaction with the UI and card behavior definition, which violates the Single Responsibility Principle. When adding new cards, you would have to change this existing code, which makes the system rigid, hard to test (since you can't test the card effects without the UI), and difficult to add on to. To solve this, I added the `CardBehavior` interface, implementing the Strategy Pattern. Each card type has its own concrete behavior class (`ShuffleBehavior`, `NopeBehavior`, `ExplodingKittenBehavior`, `DefuseBehavior`) that encapsulates all of the execution logic for that card. Each behavior implements the `execute()`, `canBeNoped()`, `endsTurn()`, and `getDescription()` methods. This allows for adding new card types just by creating new behavior classes without modifying `GameUI` or other card implementations.

I also used the Factory Pattern for card behavior creation to map card types to their concrete behaviors. Without a centralized creation mechanism, there would be `new ShuffleBehavior()` calls throughout the codebase and violate the Dependency Inversion Principle. The `CardBehaviorFactory` provides `createBehavior(CardType)` which returns the appropriate `CardBehavior` for a card type, and `hasBehavior(CardType)` which checks if a behavior exists. This follows the Single Responsibility Principle, since the factory's job is only creation, and Open/Closed Principle, since adding new cards means adding factory registrations, not changing existing code.

For the UI interaction within behaviors, we needed to decouple the domain logic from the UI layer. If we created a direct dependency from `domain.game.behaviors` to `ui.GameUI`, we would violate the Dependency Inversion Principle, since domain logic shouldn't depend on UI implementation. This would also make behaviors impossible to test without the entire UI. To solve this, I added the `UIHandler` interface in the `domain.game.behaviors` package. This interface defines the UI operations that behaviors need, and `GameUI` in the `ui` package implements this interface. Behaviors depend only on the abstract `UIHandler` interface, not the concrete `GameUI` class. This fixes the dependency direction because UI depends on Domain, not the other way around.

For card execution results, I designed a `CardResult` class. In the original design, methods like `playExplodingKitten()` returned `boolean` which were unclear. They don't make it clear whether `true` means success or elimination. Other methods were `void` and required checking global game state after. This made the code difficult to understand and test. The class I designed, `CardResult`, provides explicit, immutable return values containing `success` (whether the action completed), `message` (human-readable description), and `playerEliminated` (whether the action resulted in elimination). Factory methods like `CardResult.success()`, `CardResult.failure()`, and `CardResult.eliminated()` always make intent clear. These objects solve multiple problems. Now, there are no void methods that require state checking and testing has been improved/is easier to do.
