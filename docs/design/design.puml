@startuml

title Exploding Kittens - Refactored Design (Strategy Pattern)

package "domain.game" {
    enum GameType {
        NONE
        EXPLODING_KITTENS
        STREAKING_KITTENS
        IMPLODING_KITTENS
    }

    enum CardType {
        NOPE
        DEFUSE
        ATTACK
        SHUFFLE
        SKIP
        SEE_THE_FUTURE
        CAT_ONE
        CAT_TWO
        CAT_THREE
        CAT_FOUR
        EXPLODING_KITTEN
        STREAKING_KITTEN
        SWAP_TOP_AND_BOTTOM
        GARBAGE_COLLECTION
        CURSE_OF_THE_CAT_BUTT
        ALTER_THE_FUTURE
        CATOMIC_BOMB
        SUPER_SKIP
        MARK
        IMPLODING_KITTEN
        REVERSE
        FERAL_CAT
        TARGETED_ATTACK
        DRAW_FROM_THE_BOTTOM
        - gameType: GameType
        + CardType(gameType: GameType)
    }

    class Card {
        - cardType: CardType
        - isMarked: boolean
        - isFacedUp: boolean
        + Card(cardType: CardType)
        + getCardType(): CardType
        + markCard(): void
        + checkIfMarked(): boolean
        + setFacedUp(): void
        + checkIfFacedUp(): boolean
    }

    class Instantiator {
        + createCard(cardType: CardType): Card
        + createRandom(): Random
        + createCardList(): ArrayList<Card>
    }

    class Player {
        - playerID: int
        - hand: List<Card>
        - isDead: boolean
        - rand: Random
        - isCursed: boolean
        + Player(playerID: int, instantiator: Instantiator)
        + getPlayerID(): int
        + addDefuse(defuse: Card): void
        + addCardToHand(card: Card): void
        + hasCard(cardType: CardType): boolean
        + getHandSize(): int
        + getCardAt(index: int): Card
        + getIndexOfCard(cardType: CardType): int
        + removeCardFromHand(index: int): CardType
        + shuffleHand(): void
        + checkNumberOfCardsInHand(cardType: CardType): int
        + getIsDead(): boolean
        + setIsDead(): void
        + getIsCursed(): boolean
        + setCursed(isCursed: boolean): void
    }

    class Deck {
        - deck: List<Card>
        - rand: Random
        - gameType: GameType
        - numberOfPlayers: int
        - maxDeckSize: int
        - instantiator: Instantiator
        + getDeckSize(): int
        + getCardAtIndex(index: int): Card
        + initializeDeck(): void
        + shuffleDeck(): void
        + insertCard(cardType: CardType, numberOfCards: int, bottom: boolean): void
        + drawCard(): Card
        + drawCardFromBottom(): Card
        + setNumberOfPlayers(numberOfPlayers: int): void
        + chooseGameType(gameType: GameType): void
        + removeBombs(): int
        + insertExplodingKittenAtIndex(indexToInsert: int): void
        + insertImplodingKittenAtIndex(indexToInsert: int, card: Card): void
        # getCardTypeAtIndex(index: int): CardType
        + reorderDeckCards(newOrderIndices: int[], cardsToReorder: List<Card>): void
    }

    class Game {
        - numberOfPlayers: int
        - gameType: GameType
        - deck: Deck
        - players: Player[]
        - rand: Random
        - currentPlayerTurn: int
        - currentPlayerNumberOfTurns: int
        - isReversed: boolean
        - attackQueue: List<Integer>
        - attackCounter: int
        - numberOfAttacks: int
        - turnTracker: int[]
        - attacked: boolean
        + Game(...)
        + swapTopAndBottom(): void
        + stealRandomCard(playerToStealFrom: int): Card
        + stealTypeCard(cardType: CardType, playerToStealFrom: int): void
        + startAttackPhase(): void
        + playAttack(): void
        + playTargetedAttack(attackedPlayerIndex: int): void
        + playExplodingKitten(playerIndex: int): boolean
        + playImplodingKitten(): void
        + playDefuse(idxToInsert: int, playerIndex: int): void
        + drawFromBottom(): Card
        + playCatomicBomb(): void
        + playReverse(): void
        + playShuffle(numberOfShuffles: int): void
        + playSkip(superSkip: boolean): int
        + playGarbageCollection(cardToDiscard: CardType): void
        + getDeck(): Deck
        + incrementPlayerTurn(): void
        + getPlayerAtIndex(playerIndex: int): Player
        + getPlayerTurn(): int
        + getNumberOfPlayers(): int
        + checkNumberOfAlivePlayers(): int
        + getNumberOfTurns(): int
        + getDeckSize(): int
        + drawCard(): Card
        + checkIfPlayerDead(playerIndex: int): boolean
        + checkIfPlayerHasCard(playerIndex: int, cardType: CardType): boolean
        + getCardType(playerIndex: int, cardIndex: int): CardType
        + getHandSize(playerIndex: int): int
        .. NEW: Strategy Pattern Integration ..
        + playCardWithBehavior(cardType: CardType, playerIndex: int): CardResult
        + hasBehavior(cardType: CardType): boolean
    }
}

package "domain.game.behaviors" {
    interface CardBehavior <<Strategy>> {
        + execute(game: Game, player: Player, ui: GameUI): CardResult
        + canBeNoped(): boolean
        + endsTurn(): boolean
        + getDescription(): String
    }

    class CardResult {
        - success: boolean
        - message: String
        - playerEliminated: boolean
        + CardResult(success: boolean, message: String)
        + CardResult(success: boolean, message: String, playerEliminated: boolean)
        + isSuccess(): boolean
        + getMessage(): String
        + isPlayerEliminated(): boolean
        + {static} success(message: String): CardResult
        + {static} failure(message: String): CardResult
        + {static} eliminated(message: String): CardResult
    }

    class ShuffleBehavior {
        + execute(game: Game, player: Player, ui: GameUI): CardResult
        + canBeNoped(): boolean
        + endsTurn(): boolean
        + getDescription(): String
    }

    class NopeBehavior {
        + execute(game: Game, player: Player, ui: GameUI): CardResult
        + canBeNoped(): boolean
        + endsTurn(): boolean
        + getDescription(): String
    }

    class ExplodingKittenBehavior {
        + execute(game: Game, player: Player, ui: GameUI): CardResult
        + canBeNoped(): boolean
        + endsTurn(): boolean
        + getDescription(): String
        - findPlayerIndex(game: Game, player: Player): int
    }

    class DefuseBehavior {
        - insertionIndex: int
        + setInsertionIndex(index: int): void
        + execute(game: Game, player: Player, ui: GameUI): CardResult
        + canBeNoped(): boolean
        + endsTurn(): boolean
        + getDescription(): String
        - findPlayerIndex(game: Game, player: Player): int
    }

    class CardBehaviorFactory <<Factory>> {
        - CardBehaviorFactory()
        + {static} createBehavior(cardType: CardType): CardBehavior
        + {static} hasBehavior(cardType: CardType): boolean
    }
}

package "ui" {
    class GameUI {
        - game: Game
        - messages: ResourceBundle
        + GameUI(game: Game)
        + chooseLanguage(): void
        + chooseGame(): void
        + chooseNumberOfPlayers(): void
        + startTurn(): void
        + endGame(): void
        + checkIfGameOver(): boolean
    }

    class Main {
        + {static} main(args: String[]): void
    }
}

' Original relationships (unchanged)
Card --> CardType
CardType ..> GameType
Deck --> GameType
Deck --> Instantiator
Deck ..> Card
Game --> Deck
Game --> GameType
Game --> Player
Game ..> Card
Game ..> CardType
Player --> Card
Player ..> Instantiator
Player ..> CardType
GameUI --> Game
Main ..> Game
Main ..> GameUI
Main ..> Deck
Main ..> Player
Main ..> Instantiator
Instantiator ..> Card
Instantiator ..> CardType

' NEW: Strategy Pattern relationships
ShuffleBehavior ..|> CardBehavior
NopeBehavior ..|> CardBehavior
ExplodingKittenBehavior ..|> CardBehavior
DefuseBehavior ..|> CardBehavior

CardBehavior ..> CardResult
CardBehaviorFactory ..> CardBehavior
CardBehaviorFactory ..> CardType
CardBehaviorFactory ..> ShuffleBehavior : creates
CardBehaviorFactory ..> NopeBehavior : creates
CardBehaviorFactory ..> ExplodingKittenBehavior : creates
CardBehaviorFactory ..> DefuseBehavior : creates

Game ..> CardBehavior : uses
Game ..> CardBehaviorFactory : uses
Game ..> CardResult : returns

note right of CardBehavior
  Strategy Pattern:
  Encapsulates card actions
  as interchangeable behaviors
end note

note right of CardBehaviorFactory
  Factory Pattern:
  Creates appropriate behavior
  based on CardType
end note

@enduml
